EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
source('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
source('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HH.R')
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
zeta
m
mp
vc1
InvS2Phi
InvS2Psi
InvS2E
Y
View(dt)
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
ID
ID.period
n
n
length(unique(ID))
length(unique(data[, paste(cluster.period)]))
table(unique(cbind(data[, paste(cluster)],data[, paste(cluster.period)]))[,1])
cID.period
cID.period
X
LLold
loglik = function(theta){
beta1 = theta[1:nvar]
beta2 = theta[(nvar+1):(2*nvar)]
sphi11 = theta[(2*nvar+1)]
sphi12 = theta[(2*nvar+2)]
sphi22 = theta[(2*nvar+3)]
se11 = theta[(2*nvar+4)]
se12 = theta[(2*nvar+5)]
se22 = theta[(2*nvar+6)]
spsi11 = theta[(2*nvar+7)]
spsi12 = theta[(2*nvar+8)]
spsi22 = theta[(2*nvar+9)]
SigmaPhi = matrix(c(sphi11,sphi12,sphi12,sphi22),2,2)
SigmaPsi = matrix(c(spsi11,spsi12,spsi12,spsi22),2,2)
SigmaE = matrix(c(se11,se12,se12,se22),2,2)
InvS2Phi <- solve(SigmaPhi)
InvS2Psi <- solve(SigmaPsi)
InvS2E <- solve(SigmaE)
temp <- 0
for(j in 1:np){
N <- mp[j]
Yj <- Y[ID.period == j,,drop=FALSE]
Xj <- X[ID.period == j,,drop=FALSE]
residj <- Yj - cbind(Xj%*%beta1, Xj%*%beta2)
obs = c(t(residj))
tm1 <- (N-1)*log(det(SigmaE))+log(det(SigmaE+N*SigmaPhi))
InvSS2 <- solve(SigmaE+N*SigmaPhi)-InvS2E
#tm1 <- (N-1)*log(det(SigmaE))+log(det(SigmaE+N*(SigmaPhi+SigmaPsi)))
#InvSS2 <- solve(SigmaE+N*(SigmaPhi+SigmaPsi))-InvS2E
Invj <- kronecker(diag(nrow=N),InvS2E) +
kronecker(matrix(1,N,N),InvSS2)/N
tm2 <- c(t(obs) %*% Invj %*% obs)
temp <- temp-(tm1+tm2)/2
}
temp
}
loglik(thetah)
loglik = function(theta){
beta1 = theta[1:nvar]
beta2 = theta[(nvar+1):(2*nvar)]
sphi11 = theta[(2*nvar+1)]
sphi12 = theta[(2*nvar+2)]
sphi22 = theta[(2*nvar+3)]
se11 = theta[(2*nvar+4)]
se12 = theta[(2*nvar+5)]
se22 = theta[(2*nvar+6)]
spsi11 = theta[(2*nvar+7)]
spsi12 = theta[(2*nvar+8)]
spsi22 = theta[(2*nvar+9)]
SigmaPhi = matrix(c(sphi11,sphi12,sphi12,sphi22),2,2)
SigmaPsi = matrix(c(spsi11,spsi12,spsi12,spsi22),2,2)
SigmaE = matrix(c(se11,se12,se12,se22),2,2)
InvS2Phi <- solve(SigmaPhi)
InvS2Psi <- solve(SigmaPsi)
InvS2E <- solve(SigmaE)
temp <- 0
for(j in 1:n){
N <- m[j]
Yj <- Y[ID == j,,drop=FALSE]
Xj <- X[ID == j,,drop=FALSE]
residj <- Yj - cbind(Xj%*%beta1, Xj%*%beta2)
obs = c(t(residj))
tm1 <- (N-1)*log(det(SigmaE))+log(det(SigmaE+N*SigmaPhi))
InvSS2 <- solve(SigmaE+N*SigmaPhi)-InvS2E
#tm1 <- (N-1)*log(det(SigmaE))+log(det(SigmaE+N*(SigmaPhi+SigmaPsi)))
#InvSS2 <- solve(SigmaE+N*(SigmaPhi+SigmaPsi))-InvS2E
Invj <- kronecker(diag(nrow=N),InvS2E) +
kronecker(matrix(1,N,N),InvSS2)/N
tm2 <- c(t(obs) %*% Invj %*% obs)
temp <- temp-(tm1+tm2)/2
}
temp
}
loglik(thetah)
loglik = function(theta){
beta1 = theta[1:nvar]
beta2 = theta[(nvar+1):(2*nvar)]
sphi11 = theta[(2*nvar+1)]
sphi12 = theta[(2*nvar+2)]
sphi22 = theta[(2*nvar+3)]
se11 = theta[(2*nvar+4)]
se12 = theta[(2*nvar+5)]
se22 = theta[(2*nvar+6)]
spsi11 = theta[(2*nvar+7)]
spsi12 = theta[(2*nvar+8)]
spsi22 = theta[(2*nvar+9)]
SigmaPhi = matrix(c(sphi11,sphi12,sphi12,sphi22),2,2)
SigmaPsi = matrix(c(spsi11,spsi12,spsi12,spsi22),2,2)
SigmaE = matrix(c(se11,se12,se12,se22),2,2)
InvS2Phi <- solve(SigmaPhi)
InvS2Psi <- solve(SigmaPsi)
InvS2E <- solve(SigmaE)
temp <- 0
for(j in 1:n){
N <- m[j]/nperiods[j]
Yj <- Y[ID == j,,drop=FALSE]
Xj <- X[ID == j,,drop=FALSE]
residj <- Yj - cbind(Xj%*%beta1, Xj%*%beta2)
obs = c(t(residj))
tm1 <- nperiods[j]*(N-1)*log(det(SigmaE))+(nperiods[j]-1)*log(det(SigmaE+N*SigmaPsi))+log(det(SigmaE+N*(SigmaPsi+nperiods[j]*SigmaPhi)))
InvSS2 <- solve(SigmaE+N*SigmaPsi)-InvS2E
InvSS22 <- solve(SigmaE+N*(SigmaPsi+nperiods[j]*SigmaPhi))-solve(SigmaE+N*SigmaPsi)
Invj <- kronecker(diag(nrow=nperiods[j]),kronecker(diag(nrow=N),InvS2E) +
kronecker(matrix(1,N,N),InvSS2)/N) +
kronecker(matrix(1,nperiods[j],nperiods[j]),kronecker(matrix(1,N,N),InvSS22)/(nperiods[j]*N))
#tm1 <- (N-1)*log(det(SigmaE))+log(det(SigmaE+N*SigmaPhi))
#InvSS2 <- solve(SigmaE+N*SigmaPhi)-InvS2E
#Invj <- kronecker(diag(nrow=N),InvS2E) +
#  kronecker(matrix(1,N,N),InvSS2)/N
tm2 <- c(t(obs) %*% Invj %*% obs)
temp <- temp-(tm1+tm2)/2
}
temp
}
loglik(thetah)
thetah = c(zeta,c(SigmaPhi[!lower.tri(SigmaPhi)]),c(SigmaE[!lower.tri(SigmaE)]),c(0,0,0))
loglik(thetah)
thetah = c(zeta,c(SigmaPhi[!lower.tri(SigmaPhi)]),c(SigmaE[!lower.tri(SigmaE)]),c(SigmaPsi[!lower.tri(SigmaPsi)]))
LLold <- loglik(thetah)
LLold
source('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
source('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
source('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
mp
ID
ID.period
np
nperiods
cID.period
cID.period
mp
mp[cID.period==j]
j<-1
mp[cID.period==j]
mp[cID.period==2]
nperiods[1]
nperiods[2]
nperiods
N <- mp[cID.period==j]
N
length(N)
t <- length(N)
t
Y[cID.period == j,,drop=FALSE]
Yj <- Y[ID == j,,drop=FALSE]
Xj <- X[ID == j,,drop=FALSE]
Yj
Xj
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
model.frame(TermsX1, data = data)
fm1$modelStruct$reStruct
terms(fm1)
getME(fm1,"Z")
stop("\ncovariates do not match between endpoints.")
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
nperiods
diag(InvS2Phi,rep(InvS2Psi,nperiods[1]))
do.call(rbind, replicate(nperiods[1], InvS2Psi, simplify=FALSE))
replicate(nperiods[1], InvS2Psi, simplify=FALSE)
diag(InvS2Phi,replicate(nperiods[1], InvS2Psi, simplify=FALSE))
InvS2Phi
rbind(InvS2Phi,matrix(0,nrow=2,ncol=nperiods[1]*2))
cbind(InvS2Phi,matrix(0,nrow=2,ncol=nperiods[1]*2))
invOmega <- cbind(InvS2Phi,matrix(0,nrow=2,ncol=nperiods[1]*2))
for(j in 1:nperiods[1]){
if(j<nperiods[1])s<-cbind(matrix(0,nrow=2,ncol=j*2),InvS2Psi,matrix(0,nrow=2,ncol=nperiods[1]*2-2-j*2))
if(j==nperiods[1])s<-cbind(matrix(0,nrow=2,ncol=nperiods[1]*2),InvS2Psi)
invOmega <- rbind(invOmega,s)
}
invOmega
nperiods[1]
j<-1
if(j<nperiods[1])s<-cbind(matrix(0,nrow=2,ncol=j*2),InvS2Psi,matrix(0,nrow=2,ncol=nperiods[1]*2-2-j*2))
matrix(0,nrow=2,ncol=nperiods[1]*2-2-j*2)
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
invOmega <- cbind(InvS2Phi,matrix(0,nrow=2,ncol=nperiods[1]*2))
j<-1
matrix(0,nrow=2,ncol=nperiods[1]*2-2-j*2)
matrix(0,nrow=2,ncol=j*2)
InvS2Psi
cbind(matrix(0,nrow=2,ncol=j*2),InvS2Psi,matrix(0,nrow=2,ncol=nperiods[1]*2-2-j*2))
s<-cbind(matrix(0,nrow=2,ncol=j*2),InvS2Psi,matrix(0,nrow=2,ncol=nperiods[1]*2-2-j*2))
invOmega
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
invOmega <- cbind(InvS2Phi,matrix(0,nrow=2,ncol=nperiods[1]*2))
for(j in 1:nperiods[1]){
if(j<nperiods[1]) {s<-cbind(matrix(0,nrow=2,ncol=j*2),InvS2Psi,matrix(0,nrow=2,ncol=nperiods[1]*2-2-j*2))}
if(j==nperiods[1]) {s<-cbind(matrix(0,nrow=2,ncol=nperiods[1]*2),InvS2Psi)}
invOmega <- rbind(invOmega,s)
}
j<-1
if(j<nperiods[1]) {s<-cbind(matrix(0,nrow=2,ncol=j*2),InvS2Psi,matrix(0,nrow=2,ncol=nperiods[1]*2-2-j*2))}
j<-4
cbind(matrix(0,nrow=2,ncol=j*2),InvS2Psi,matrix(0,nrow=2,ncol=nperiods[1]*2-2-j*2))
nperiods[1]*2-2-j*2
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
invOmega
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
A[ID == j,,drop=FALSE]
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
t(Aj)
t(Aj)%*%Aj
t(Aj)%*%Aj%*%InvS2E
t(Aj)%*%Aj
invOmega
t(Aj)%*%Aj
Aj
cbind(diag(1,nrow=2,ncol=2),diag(1,nrow=2,ncol=2),matrix(0,nrow=2,ncol=nperiods[1]*2-2))
debugSource('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HoopGir.R')
EM.estim(dt,lme1,lme2,cluster="cluster",cluster.period="cluster.period",verbose=TRUE)
A
invOmega
datagen_cont <- function(n, m, K, cv, sigmac, sigmae, eff, time.eff ){
# n -number of clusters
# m - cluster size
# K - number of multiple co-primary outcomes
# cv - cluster size coefficient of variation
# sigmac - correlation matrix of random cluster effects
# sigmae - correlation matrix of random errors
# eff - a vector of treatment effect sizes
# time.eff - vector of time effects (order is by primary outcome and period)
library(MASS)
DATA<-NULL
temp<-NULL
nperiods<-length(time.eff)/2 + 1
if (cv>0){
#parameters in gamma distribution
kappa <- 1/cv^2
theta <- m*cv^2
# generate m from gamma
mj <- round(rgamma(n, shape=kappa,  scale = theta))
}else{
#total sample size
mj <- rep(m, n)
}
#total sample size
#n=sum(mj)
n.sub=sum(mj)*nperiods                               # KP: Assuming cluster size does not change over time. n = I*N*T in notes
#cluster <- rep(1:(2*Narm),  mj);
cluster <- rep(1:n,  mj*nperiods);
#generate patient id
patid <- seq(1:n)
temp <- cbind(patid, cluster)
temp <- as.data.frame(temp)
#randomize treatment assignment
#T <- rep(0, 2*Narm)
#t <- sample(x=1:(2*Narm), size=Narm)
#T[t] <- 1
trtSeq<-matrix(0,nperiods-1,nperiods)
trtSeq[upper.tri(trtSeq)]<-1
trtSeq<-trtSeq[rep(1:nrow(trtSeq), rep(n/(nperiods-1),(nperiods-1))),]
if(sum(rep(n/(nperiods-1),(nperiods-1))) != n){stop("invalid randomization scheme")}
# time: need to repeat each element in c(0,1,...,T) mj times and concatenate all clusters
for(i in 1:length(mj)) {if(i==1){time<-rep(0:(nperiods-1), each=mj[1])}else{if(i>1){time<-c(time,rep(0:(nperiods-1), each=mj[i]))}}}
temp2 <- cbind(temp, time)
#arm=0 if in the control group, arm=1 if in the intervention group
#arm <- rep(T,  mj)
temp2$arm<-0
for(i in 1:nrow(temp2)) {
temp2$arm[i]<-trtSeq[temp2$cluster[i],(temp2$time[i]+1)]
}
# create indicator variables for time
for(i in 1:(nperiods-1)) {temp2[, paste0("time.", i)]<-ifelse(temp2$time==i,1,0)}
DATA <- temp2[rep(1:nrow(temp2), each = K), ]
#individual random effect
# Parameters for bivariate normal distribution
mu <- rep(0,K) # Mean
epsilon <- mvrnorm(n*nperiods*m, mu = mu, Sigma = sigmae ) # from MASS package
#cluster random effect
g <- mvrnorm(n, mu = mu, Sigma = sigmac )
#replicate row
#gamma <- g[rep(1:nrow(g),  mj), ]
gamma <- g[rep(1:nrow(g),  mj*nperiods), ]
#intercept
#int <- c(5, 0)
#tht <-matrix(temp2$arm) %*% matrix(eff,nrow=1) +gamma+epsilon
# with positive interaction
# time effects
time.effect<-rep(0,K)
for(i in 1:(nperiods-1)){
time.effect<-time.effect+matrix(temp2[, paste0("time.", i)]) %*% matrix(time.eff[c(i,(i+nperiods-1))],nrow=1)
}
Y <- time.effect + matrix(temp2$arm) %*% matrix(eff,nrow=1) +gamma+epsilon
colnames(Y) <- paste("out",seq(1,K),sep="")
Yc <- as.vector(t(Y))
#Idct<- diag(1,K)
#H= Idct[rep(1:nrow(Idct), time = nrow(Y)), ]
label = rep(1:K,n)
# design matrix
full <- cbind(DATA, Yc, label)
full <- data.frame(full)
short <- cbind(temp2,Y )
return(list(long=full, short=short))
}
source('~/Documents/GitHub/CoPrimarySWCRT/gendata_copri_varCluster_HH.R')
library(nlme)
library(foreach)
#set.seed(3628) #1000 iterations
set.seed(5792) #10000 iterations
dt<-datagen_cont(n=150, m=15, K=2, cv=0, sigmac=matrix(c(1.3,0.15,0.15,1.1),2), sigmae= matrix(c(2,0.1,0.1,1.5),2), eff=c(1,0.5), time.eff=c(1.1,1.3,1.4,0.9,0.7,0.5))$short
lme1<-lme(out1~time.1+time.2+time.3+arm,random=~1|cluster,data=dt,control=lmeControl(returnObject=TRUE))
lme2<-lme(out2~time.1+time.2+time.3+arm,random=~1|cluster,data=dt,control=lmeControl(returnObject=TRUE))
source('~/Documents/GitHub/CoPrimarySWCRT/EM_uncorrected_HH.R')
EM.estim(dt,lme1,lme2)
source('~/Documents/GitHub/CoPrimarySWCRT/EMcorrected_generalf_K2_HH.R')
EM.estim(dt,lme1,lme2)
source('~/Documents/GitHub/CoPrimarySWCRT/EMcorrected_generalf_K2_HH.R')
EM.estim(dt,lme1,lme2)
source('~/Documents/GitHub/CoPrimarySWCRT/EMcorrected_hybrid_K2_HH.R')
EM.estim(dt,lme1,lme2)
fitEM$SEtheta
fitEM<-EM.estim(dt,lme1,lme2)
betas<-fitEM$theta$zeta
SigmaE<-c(fitEM$theta$SigmaE[!lower.tri(fitEM$theta$SigmaE)])
SigmaPhi<-c(fitEM$theta$SigmaPhi[!lower.tri(fitEM$theta$SigmaPhi)])
iter<-fitEM$iter
SEtheta<-fitEM$SEtheta
SEtheta
c(betas,SigmaPhi,SigmaE,SEtheta)
simData<-c(betas,SigmaPhi,SigmaE,SEtheta)
colnames(simData)<-c("Intercept.est1","Time1.est1","Time2.est1","Time3.est1","Treatment.est1",
"Intercept.est2","Time1.est2","Time2.est2","Time3.est2","Treatment.est2",
"SigmaPhi11","SigmaPhi12","SigmaPhi22","SigmaE11","SigmaE12","SigmaE22",
"Intercept.se1","Time1.se1","Time2.se1","Time3.se1","Treatment.se1",
"Intercept.se2","Time1.se2","Time2.se2","Time3.se2","Treatment.se2")
betas
SigmaE
SigmaPhi
SEtheta
library(mvtnorm)
t=4
I=(t-1)*10
X<-NULL
trtSeq<-matrix(0,t-1,t)
trtSeq[upper.tri(trtSeq)]<-1
g<-I/(t-1) # number of clusters per step
X=trtSeq[rep(1:nrow(trtSeq),each=g),]
X
U=sum(X)
V=sum((rowSums(X))^2)
W=sum((colSums(X))^2)
t=5           # number of periods
I=(t-1)*2     # number of clusters
# Create X matrix
X<-NULL
trtSeq<-matrix(0,t-1,t)
trtSeq[upper.tri(trtSeq)]<-1
g<-I/(t-1) # number of clusters per step
X=trtSeq[rep(1:nrow(trtSeq),each=g),]
Omega <- crossprod((diag(I)-(1/I)*matrix(1,I,I))%*%X)/I
U=sum(X)
V=sum((rowSums(X))^2)
W=sum((colSums(X))^2)
Omega
matrix(1,1,t)%*%Omega%*%matrix(1,t,1)
I
X<-NULL
trtSeq<-matrix(0,t-1,t)
trtSeq[1:(nrow(trtSeq)/2),]<-1
g<-I/(t-1) # number of clusters per step
X=trtSeq[rep(1:nrow(trtSeq),each=g),]
U=sum(X)
V=sum((rowSums(X))^2)
W=sum((colSums(X))^2)
(I*U-W)/I^2
(I*U-W)/I^2
crossprod((diag(I)-(1/I)*matrix(1,I,I))%*%X)/I
t=5           # number of periods
I=(t-1)*2     # number of clusters
# Create X matrix
X<-NULL
trtSeq<-matrix(0,t-1,t)
trtSeq[upper.tri(trtSeq)]<-1
g<-I/(t-1) # number of clusters per step
X=trtSeq[rep(1:nrow(trtSeq),each=g),]
X
betas=c(2,1.5); deltas=c(0,0); vars.b=c(0.8,0.75); vars.eps=c(1,0.9); rho.b=0.05; rho.eps=0.01; t=4; n=(t-1)*2; m=7; k=2; alpha=0.05
X<-NULL
trtSeq<-matrix(0,t-1,t)
trtSeq[upper.tri(trtSeq)]<-1
g<-I/(t-1) # number of clusters per step
X=trtSeq[rep(1:nrow(trtSeq),each=g),]
U=sum(X)
V=sum((rowSums(X))^2)
W=sum((colSums(X))^2)
Sigmab_Matrix <- diag(vars.b)
SigmaE_Matrix <- diag(vars.eps)
for(row in 1:K )
{
for(col in 1:K)
{
if(row != col){
Sigmab_Matrix[row,col] <- sqrt(vars.b[row])*sqrt(vars.b[col])*rho.b[row,col]
SigmaE_Matrix[row,col] <- sqrt(vars.eps[row])*sqrt(vars.eps[col])*rho.eps[row,col]
}
}
}
Sigmab_Matrix <- diag(vars.b)
SigmaE_Matrix <- diag(vars.eps)
for(row in 1:k)
{
for(col in 1:k)
{
if(row != col){
Sigmab_Matrix[row,col] <- sqrt(vars.b[row])*sqrt(vars.b[col])*rho.b[row,col]
SigmaE_Matrix[row,col] <- sqrt(vars.eps[row])*sqrt(vars.eps[col])*rho.eps[row,col]
}
}
}
Sigmab_Matrix <- diag(vars.b)
SigmaE_Matrix <- diag(vars.eps)
for(row in 1:k-1)
{
for(col in 1:k-1)
{
if(row != col){
Sigmab_Matrix[row,col] <- sqrt(vars.b[row])*sqrt(vars.b[col])*rho.b[row,col]
SigmaE_Matrix[row,col] <- sqrt(vars.eps[row])*sqrt(vars.eps[col])*rho.eps[row,col]
}
}
}
library(nlme)
library(doMC)
library(doRNG)
library(lmeInfo)
setwd("/Users/kdavis07/Documents/GitHub/CoPrimarySWCRT")
source("gendata_copri_varCluster_HH.R")
source("EM_uncorrected_HH.R")
args<-commandArgs(trailingOnly = TRUE)
k<-as.integer(args[1])
if (is.na(k)) k <- 23
paste("Scenario:",k)
ncores<-as.numeric(Sys.getenv("SLURM_CPUS_PER_TASK",1))
if (is.na(ncores)) ncores<-1
registerDoMC(cores=ncores)
# define scenarios
scenarios <- read.table("/Users/kdavis07/Dropbox/SW-CRT Methods Development/2_CoPrimary/RCode/Simulations/Sim_Params.txt", header=TRUE, sep="")
scenarios <- subset(scenarios, scenario == k)
scenario <- k
t <- scenarios$t
N <- scenarios$N
cs <- scenarios$m
eff<-c(scenarios$delta1,scenarios$delta2)
rho01<-matrix(c(scenarios$rho01.11,scenarios$rho01.12,scenarios$rho01.12,scenarios$rho01.22),2)
rho2<-matrix(c(1,scenarios$rho2.12,scenarios$rho2.12,1),2)
vars<-c(1,1) #c(scenarios$var1,scenarios$var2)
bs <- 0
beta <- cumsum(c(0.1,0.1*0.5,0.1*(0.5^2),0.1*(0.5^3),0.1*(0.5^4),0.1*(0.5^5)))[1:t-1]
nsim<-2
set.seed(8374+k)
fail_count <- 0
max_fail <- 200
for(i in 1:266){
dt<-datagen_cont(n=N, m=cs, K=2, cv=0, rho01=rho01, rho2=rho2, vars=vars, eff=eff, time.eff=c(beta,beta))
}
data<-dt$short
if(t==3){
lme1<-lme(out1~time.1+time.2+arm,random=~1|cluster,data=data,control=lmeControl(returnObject=TRUE))
lme2<-lme(out2~time.1+time.2+arm,random=~1|cluster,data=data,control=lmeControl(returnObject=TRUE))
}
if(t==4){
lme1<-lme(out1~time.1+time.2+time.3+arm,random=~1|cluster,data=data,control=lmeControl(returnObject=TRUE))
lme2<-lme(out2~time.1+time.2+time.3+arm,random=~1|cluster,data=data,control=lmeControl(returnObject=TRUE))
}
if(t==5){
lme1<-lme(out1~time.1+time.2+time.3+time.4+arm,random=~1|cluster,data=data,control=lmeControl(returnObject=TRUE))
lme2<-lme(out2~time.1+time.2+time.3+time.4+arm,random=~1|cluster,data=data,control=lmeControl(returnObject=TRUE))
}
param<-try(EM.estim(data,lme1,lme2, maxiter=500, epsilon=1e-4, verbose=FALSE))
param$SEtheta
